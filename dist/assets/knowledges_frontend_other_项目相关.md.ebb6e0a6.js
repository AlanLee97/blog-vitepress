import{_ as s,o as a,c as l,g as n}from"./app.00ab700b.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"1. 跨域问题","slug":"_1-跨域问题","link":"#_1-跨域问题","children":[]},{"level":3,"title":"2. 网站安全问题","slug":"_2-网站安全问题","link":"#_2-网站安全问题","children":[]},{"level":3,"title":"","slug":"","link":"#","children":[]},{"level":3,"title":"3. 单页面应用的优缺点","slug":"_3-单页面应用的优缺点","link":"#_3-单页面应用的优缺点","children":[]},{"level":3,"title":"4. 首屏渲染优化","slug":"_4-首屏渲染优化","link":"#_4-首屏渲染优化","children":[]},{"level":3,"title":"5. 网站性能优化","slug":"_5-网站性能优化","link":"#_5-网站性能优化","children":[]},{"level":3,"title":"6. 移动端适配","slug":"_6-移动端适配","link":"#_6-移动端适配","children":[]}],"relativePath":"knowledges/frontend/other/项目相关.md","lastUpdated":1678293877000}'),p={name:"knowledges/frontend/other/项目相关.md"},e=n(`<h3 id="_1-跨域问题" tabindex="-1">1. 跨域问题 <a class="header-anchor" href="#_1-跨域问题" aria-hidden="true">#</a></h3><h4 id="同源策略" tabindex="-1">同源策略 <a class="header-anchor" href="#同源策略" aria-hidden="true">#</a></h4><p>同源：协议，域名，端口三者相同。 例如：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">http</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//www.baidu.com 和 http://www.baidu.com/search  // 同源</span></span>
<span class="line"><span style="color:#FFCB6B;">http</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//www.baidu.com 和 https://www.baidu.com  // 不同源，协议不同</span></span>
<span class="line"><span style="color:#FFCB6B;">http</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//music.baidu.com 和 http://tieba.baidu.com  // 不同源，域名不同</span></span>
<span class="line"><span style="color:#FFCB6B;">http</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//www.baidu.com:81 和 http://www.baidu.com:82  // 不同源，端口不同</span></span>
<span class="line"></span></code></pre></div><p>同源策略是浏览器自身增加的安全限制。</p><p>如果不同源请求数据，就会触发跨域问题。</p><h4 id="解决方法" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法" aria-hidden="true">#</a></h4><ol><li>服务端设置响应头** **Access-Control-Allow-Origin: *</li><li>jsonp，该方式只支持get请求</li><li>代理</li><li>Nginx代理</li></ol><h3 id="_2-网站安全问题" tabindex="-1">2. 网站安全问题 <a class="header-anchor" href="#_2-网站安全问题" aria-hidden="true">#</a></h3><h4 id="跨站脚本攻击xss" tabindex="-1">跨站脚本攻击XSS <a class="header-anchor" href="#跨站脚本攻击xss" aria-hidden="true">#</a></h4><p>跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程序代码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。 XSS 分为三种：反射型，存储型和 DOM-based</p><p><strong>攻击方式</strong> XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。 例如通过 URL 获取某些参数</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;!--</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">http</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{{</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>上述 URL 输入可能会将 HTML 改为<code>&lt;div&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/div&gt;</code>，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。</p><p><strong>防御措施</strong> 最普遍的做法是使用正则匹配需要转义的字符，转义输入输出的内容，对于<strong>引号</strong>，<strong>尖括号</strong>，<strong>斜杠</strong>进行转义。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">escape</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">str</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">str</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">str</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">replace</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">/</span><span style="color:#C3E88D;">&amp;</span><span style="color:#89DDFF;">/</span><span style="color:#F78C6C;">g</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&amp;amp;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">str</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">str</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">replace</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">/</span><span style="color:#C3E88D;">&lt;</span><span style="color:#89DDFF;">/</span><span style="color:#F78C6C;">g</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&amp;lt;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">str</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">str</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">replace</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">/</span><span style="color:#C3E88D;">&gt;</span><span style="color:#89DDFF;">/</span><span style="color:#F78C6C;">g</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&amp;gt;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">str</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">str</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">replace</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">/</span><span style="color:#C3E88D;">&quot;</span><span style="color:#89DDFF;">/</span><span style="color:#F78C6C;">g</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&amp;quto;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">str</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">str</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">replace</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">/</span><span style="color:#C3E88D;">&#39;</span><span style="color:#89DDFF;">/</span><span style="color:#F78C6C;">g</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&amp;#39;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">str</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">str</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">replace</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">/</span><span style="color:#C3E88D;">\`</span><span style="color:#89DDFF;">/</span><span style="color:#F78C6C;">g</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&amp;#96;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">str</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">str</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">replace</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">\\/</span><span style="color:#89DDFF;">/</span><span style="color:#F78C6C;">g</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&amp;#x2F;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">str</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>通过转义可以将攻击代码<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>变成</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;</span></span>
<span class="line"><span style="color:#82AAFF;">escape</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&lt;script&gt;alert(1)&lt;/script&gt;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用<strong>白名单过滤</strong>的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> xss </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xss</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> html </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">xss</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(html)</span></span>
<span class="line"></span></code></pre></div><p>以上示例使用了js-xss来实现。可以看到在输出中保留了h1标签且过滤了script标签</p><h4 id="csrf攻击" tabindex="-1">CSRF攻击 <a class="header-anchor" href="#csrf攻击" aria-hidden="true">#</a></h4><p>跨站请求伪造（英语：Cross-site request forgery），也被称为one-click attack或者session riding，通常缩写为CSRF或者XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站指令码（XSS）相比，XSS利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 简单点说，CSRF 就是利用用户的登录态发起恶意请求。</p><p><strong>攻击方式</strong> 例如某家银行的转账 API 的URL 是这样的：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">http</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</span></span>
<span class="line"></span></code></pre></div><p>而恶意用户如果在网站中塞进一个 <img> 的话：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">img</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>当不知情的用户浏览到攻击者的网站时，<img> 会自动发出这个请求，如果用户登录银行的 Session 尚未过期，那么这个请求很可能就会被银行接受，最后会在用户本人不知情的情况下“被”转帐。 这种攻击方式可以与前面所说的 XSS 是相辅相成，例如在没有防范 XSS 的论坛网站中植入 <img>，那么其 src 属性就应该是获取敏感信息的 API URL。</p><p><strong>防御措施</strong> 防范 CSRF 可以遵循以下几种规则：</p><ol><li>Get 请求不对数据进行修改</li><li>不让第三方网站访问到用户 Cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者 token</li></ol><p><strong>1.SameSite</strong> 可以对 Cookie 设置SameSite属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。 <strong>2.验证 Referer</strong> 在服务器端检查请求头中 Referer 的值，也就是检查请求的来源，如果是来自允许的网站，才会正常执行 API 的功能。 <strong>3.CSRF Token</strong> 在 Cookie 及请求发送的数据中都加上csrftoken，并检查值是否相同，如果请求来源是自己的网站验证就会通过；反之，由于外部网站无法在代码中得到其他网站的 Cookie，因此无法在请求中带上csrftoken。</p><h4 id="富文本如何防攻击" tabindex="-1">富文本如何防攻击 <a class="header-anchor" href="#富文本如何防攻击" aria-hidden="true">#</a></h4><p>对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用<strong>白名单过滤</strong>的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> xss </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xss</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> html </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">xss</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(html)</span></span>
<span class="line"></span></code></pre></div><p>以上示例使用了js-xss来实现。可以看到在输出中保留了h1标签且过滤了script标签</p><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h3><h3 id="_3-单页面应用的优缺点" tabindex="-1">3. 单页面应用的优缺点 <a class="header-anchor" href="#_3-单页面应用的优缺点" aria-hidden="true">#</a></h3><h4 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-hidden="true">#</a></h4><ol><li>前后端分离</li><li>良好的交互体验——用户不用刷新页面，页面显示流畅</li><li>减轻服务器压力——服务器只出数据</li><li>共用一套后端代码——多个客户端可共用一套后端代码</li></ol><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-hidden="true">#</a></h4><ol><li>首次加载慢</li><li>seo难度高——数据渲染在前端进行，seo主要是让网站对于搜索引擎的爬虫更加友好，spa页数据动态生成，爬虫识别不了</li><li>前进后退管理——单页面不能使用浏览器的前进后退，页面切换要自己建立堆栈管理，解决方法：利用url的散列+iframe实现</li></ol><h3 id="_4-首屏渲染优化" tabindex="-1">4. 首屏渲染优化 <a class="header-anchor" href="#_4-首屏渲染优化" aria-hidden="true">#</a></h3><ol><li>webpack打包按需加载</li><li>路由懒加载</li><li>使用webpack预渲染插件</li><li>启用gzip压缩</li><li>使用服务端渲染SSR</li></ol><h3 id="_5-网站性能优化" tabindex="-1">5. 网站性能优化 <a class="header-anchor" href="#_5-网站性能优化" aria-hidden="true">#</a></h3><h4 id="网络相关" tabindex="-1">网络相关 <a class="header-anchor" href="#网络相关" aria-hidden="true">#</a></h4><h4 id="_1-dns-预解析" tabindex="-1">1. DNS 预解析 <a class="header-anchor" href="#_1-dns-预解析" aria-hidden="true">#</a></h4><p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">rel</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">dns-prefetch</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">href</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">//baidu.com</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"></span></code></pre></div><h4 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a></h4><ol start="2"><li>缓存 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。 通常浏览器缓存策略分为两种：强缓存和协商缓存。 <strong>1.强缓存</strong> 实现强缓存可以通过两种响应头实现：Expires和Cache-Control。强缓存表示在缓存期间不需要请求，state code为 200 <code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//baidu.com&quot; /&gt;</code></li></ol><p><strong>Expires</strong>是 HTTP / 1.0 的产物，表示资源会在Wed, 22 Oct 2018 08:41:00 GMT后过期，需要再次请求。并且Expires受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 Cache-control: max-age=30</p><p><strong>Cache-Control</strong>出现于 HTTP / 1.1，优先级高于Expires。该属性表示资源会在 30 秒后过期，需要再次请求。</p><p><strong>2.协商缓存</strong> 如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p><h5 id="last-modified-和-if-modified-since" tabindex="-1">Last-Modified 和 If-Modified-Since <a class="header-anchor" href="#last-modified-和-if-modified-since" aria-hidden="true">#</a></h5><p>Last-Modified表示本地文件最后修改日期，If-Modified-Since会将Last-Modified的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成Last-Modified被修改，所以在 HTTP / 1.1 出现了ETag。</p><h5 id="etag-和-if-none-match" tabindex="-1">ETag 和 If-None-Match <a class="header-anchor" href="#etag-和-if-none-match" aria-hidden="true">#</a></h5><p>ETag类似于文件指纹，If-None-Match会将当前ETag发送给服务器，询问该资源ETag是否变动，有变动的话就将新的资源发送回来。并且ETag优先级比Last-Modified高。</p><p>选择合适的缓存策略 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p><ul><li>对于某些不需要缓存的资源，可以使用Cache-control: no-store，表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用Cache-Control: no-cache并配合ETag使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用Cache-Control: max-age=31536000并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li></ul><h4 id="_3-使用-http-2-0" tabindex="-1">3. 使用 HTTP / 2.0 <a class="header-anchor" href="#_3-使用-http-2-0" aria-hidden="true">#</a></h4><p>因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。</p><h4 id="_4-预加载" tabindex="-1">4. 预加载 <a class="header-anchor" href="#_4-预加载" aria-hidden="true">#</a></h4><p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。 预加载其实是声明式的fetch，强制浏览器请求资源，并且不会阻塞onload事件，可以使用以下代码开启预加载</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">rel</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">preload</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">href</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">http://example.com</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"></span></code></pre></div><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p><h4 id="_5-预渲染" tabindex="-1">5. 预渲染 <a class="header-anchor" href="#_5-预渲染" aria-hidden="true">#</a></h4><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">rel</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">prerender</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">href</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">http://example.com</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"></span></code></pre></div><p>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</p><h4 id="优化渲染过程" tabindex="-1">优化渲染过程 <a class="header-anchor" href="#优化渲染过程" aria-hidden="true">#</a></h4><p>对于代码层面的优化，你可以查阅浏览器系列中的<a href="https://yuchengkai.cn/docs/Browser/browser-ch.html##%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6" target="_blank" rel="noreferrer">相关内容</a>。</p><h4 id="_1-懒执行" tabindex="-1">1. 懒执行 <a class="header-anchor" href="#_1-懒执行" aria-hidden="true">#</a></h4><p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p><h4 id="_2-懒加载" tabindex="-1">2.懒加载 <a class="header-anchor" href="#_2-懒加载" aria-hidden="true">#</a></h4><p>懒加载就是将不关键的资源延后加载。 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的src属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为src属性，这样图片就会去下载资源，实现了图片懒加载。 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</p><h4 id="文件优化" tabindex="-1">文件优化 <a class="header-anchor" href="#文件优化" aria-hidden="true">#</a></h4><h4 id="_1-图片优化" tabindex="-1">1. 图片优化 <a class="header-anchor" href="#_1-图片优化" aria-hidden="true">#</a></h4><p><strong>计算图片大小</strong> 对于一张 100 _ 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1 个字节），所以该图片大小大概为 39KB（10000 _ 1 * 4 / 1024）。 但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。 了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</p><ul><li>减少像素点</li><li>减少每个像素点能够显示的颜色</li></ul><p><strong>图片加载优化</strong></p><ol><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 base64 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式： <ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li><li>照片使用 JPEG</li></ul></li></ol><h4 id="_2-其他文件优化" tabindex="-1">2. 其他文件优化 <a class="header-anchor" href="#_2-其他文件优化" aria-hidden="true">#</a></h4><ul><li>CSS 文件放在head中</li><li>服务端开启gzip文件压缩功能</li><li>减少重排与重绘</li><li>将script标签放在body底部，因为 JS 文件执行会阻塞渲染。当然也可以把script标签放在任意位置然后加上defer，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上async，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。</li><li>执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用Webworker。Webworker可以让我们另开一个线程执行脚本而不影响渲染。</li></ul><h4 id="_3-cdn" tabindex="-1">3. CDN <a class="header-anchor" href="#_3-cdn" aria-hidden="true">#</a></h4><p>静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。</p><h4 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-hidden="true">#</a></h4><h4 id="_1-使用-webpack-优化项目" tabindex="-1">1.使用 Webpack 优化项目 <a class="header-anchor" href="#_1-使用-webpack-优化项目" aria-hidden="true">#</a></h4><ul><li>对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩</li><li>使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码</li><li>优化图片，对于小图可以使用 base64 的方式写入文件中</li><li>按照路由拆分代码，实现按需加载</li><li>给打包出来的文件名添加哈希，实现浏览器缓存文件</li></ul><h4 id="_2-监控" tabindex="-1">2. 监控 <a class="header-anchor" href="#_2-监控" aria-hidden="true">#</a></h4><p>对于代码运行错误，通常的办法是使用window.onerror拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外</p><ul><li>对于跨域的代码运行错误会显示Script error.对于这种情况我们需要给script标签添加crossorigin属性</li><li>对于某些浏览器可能不会显示调用栈信息，这种情况可以通过arguments.callee.caller来做栈递归</li></ul><p>对于异步代码来说，可以使用catch的方式捕获错误。比如Promise可以直接使用catch函数，async await可以使用try catch 但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。 对于捕获的错误需要上传给服务器，通常可以通过img标签的src发起一个请求。</p><h3 id="_6-移动端适配" tabindex="-1">6. 移动端适配 <a class="header-anchor" href="#_6-移动端适配" aria-hidden="true">#</a></h3>`,93),o=[e];function t(r,c,i,F,y,d){return a(),l("div",null,o)}const C=s(p,[["render",t]]);export{h as __pageData,C as default};
