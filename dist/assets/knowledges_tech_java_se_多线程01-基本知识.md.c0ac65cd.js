import{_ as a,o as e,c as l,b as i}from"./app.d2d47940.js";const g=JSON.parse('{"title":"Java多线程","description":"","frontmatter":{"date":"2020-01-30T00:00:00.000Z","categories":["后端"],"tags":["java"]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"一个线程的生命周期","slug":"一个线程的生命周期","link":"#一个线程的生命周期","children":[]},{"level":2,"title":"线程的优先级","slug":"线程的优先级","link":"#线程的优先级","children":[]},{"level":2,"title":"创建一个线程","slug":"创建一个线程","link":"#创建一个线程","children":[]},{"level":2,"title":"问题","slug":"问题","link":"#问题","children":[]}],"relativePath":"knowledges/tech/java/se/多线程01-基本知识.md","lastUpdated":1678618356000}'),t={name:"knowledges/tech/java/se/多线程01-基本知识.md"},n=i('<h1 id="java多线程" tabindex="-1">Java多线程 <a class="header-anchor" href="#java多线程" aria-hidden="true">#</a></h1><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-hidden="true">#</a></h2><p>Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。</p><p>这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p><h2 id="一个线程的生命周期" tabindex="-1">一个线程的生命周期 <a class="header-anchor" href="#一个线程的生命周期" aria-hidden="true">#</a></h2><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p><p>下图显示了一个线程完整的生命周期。</p><ul><li></li></ul><p>新建状态:</p><p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p><ul><li></li></ul><p>就绪状态:</p><p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p><ul><li></li></ul><p>运行状态:</p><p>如果就绪状态的线程获取 CPU 资源，就可以执行 <strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p><ul><li></li></ul><p>阻塞状态:</p><p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li><li></li></ul><p>死亡状态:</p><p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p><h2 id="线程的优先级" tabindex="-1">线程的优先级 <a class="header-anchor" href="#线程的优先级" aria-hidden="true">#</a></h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p><p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p><p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><h2 id="创建一个线程" tabindex="-1">创建一个线程 <a class="header-anchor" href="#创建一个线程" aria-hidden="true">#</a></h2><p>Java 提供了三种创建线程的方法：</p><ul><li>通过实现 Runnable 接口；</li><li>通过继承 Thread 类本身；</li><li>通过 Callable 和 Future 创建线程。</li></ul><h2 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-hidden="true">#</a></h2><p><strong>Runnable与Callable有什么区别？</strong></p><ul><li>Runnable是在JDK1.0的时候提出的多线程实现接口，而Callable是在JDK1.5之后提出的。</li><li>java.lang.Runnable接口之中只提供有一个run()方法，并且没有返回值。</li><li>java.util.concurrent.Callable接口提供有call方法，可以有返回值。</li></ul>',34),r=[n];function s(d,p,h,o,c,u){return e(),l("div",null,r)}const v=a(t,[["render",s]]);export{g as __pageData,v as default};
